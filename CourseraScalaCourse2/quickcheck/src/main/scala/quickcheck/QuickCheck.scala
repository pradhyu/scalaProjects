package quickcheck

import common._

import org.scalacheck._
import Arbitrary._
import Gen._
import Prop._

abstract class QuickCheckHeap extends Properties("Heap") with IntHeap {

  // To get you in shape, here is an example of a generator for maps of type Map[Int,Int].
  lazy val genMap: Gen[Map[Int, Int]] = oneOf(
    const(Map.empty[Int, Int]),
    for {
      key <- arbitrary[Int]
      value <- arbitrary[Int]
      map <- oneOf(const(Map.empty[Int, Int]), genMap)
    } yield map.updated(key, value)
  )

  // genHeap generator
  //We also recommend you write a generator of heaps, of abstract type H,
  // so that you can write properties on any random heap,
  // generated by your procedure. For example,
  lazy val genHeap: Gen[H] = for {
    element <- arbitrary[Int]
    h <- oneOf(const(empty), genHeap)
  } yield insert(element, h)

  implicit lazy val arbHeap: Arbitrary[H] = Arbitrary(genHeap)

  //As an example of what you should do, here is a property that ensures
  // that if you insert an element into an empty heap,
  // then find the minimum of the resulting heap,
  // you get the element back:
  property("min1") = forAll { element: Int =>
    val h = insert(element, empty)
    findMin(h) == element
  }

  // property on any random heap, generated by your procedure
  property("gen1") = forAll { h: H =>
    val m = if (isEmpty(h)) 0 else findMin(h)
    findMin(insert(m, h)) == m
  }

  // If you insert any two elements into an empty heap,
  // finding the minimum of the resulting heap
  // should get the smallest of the two elements back.
  property("insTwoElemInEmpty") = forAll { (element1: Int, element2: Int) =>
    val heap = insert(element2, insert(element1, empty))
    val smallestElement = if (element1 < element2) element1 else element2
    findMin(heap) == smallestElement
  }

  // If you insert an element into an empty heap,
  // then delete the minimum, the resulting heap should be empty.
  property("insertThenDelMin") = forAll { element: Int =>
    val h = insert(element, empty)
    val h1 = deleteMin(h)
    h1 == empty
  }

  // Finding a minimum of the melding of
  // any two heaps should return a minimum of one or the other.
  property("meldMin") = forAll { (h1: H, h2: H) =>
    val min1 = findMin(h1)
    val min2 = findMin(h2)
    val meldedHeap = meld(h1, h2)
    val minMeld = findMin(meldedHeap)
    // min of melded heap should either be min of heap1 or min of heap2
    minMeld == min1 || minMeld == min2
  }

  // Given any heap, you should get a sorted sequence
  // of elements when continually finding and deleting minima.
  // (Hint: recursion and helper functions are your friends.)
  property("findAndRemoveMinShoudReturnSortedList") = forAll { h: H =>
    def removeMin(ts: H, as: List[Int]): List[Int] = {
      if (isEmpty(ts)) as
      else findMin(ts) :: removeMin(deleteMin(ts), as)
    }

    // recursive call should result in sorted elements in the list.
    val xs = removeMin(h, Nil)
    xs == xs.sorted
  }

  // Take two arbitrary heaps, meld together.
  // Then remove min from 1 and insert into 2,
  // meld the results. Compare two melds by comparing sequences of ranks.
  property("meldMinMove") = forAll { (h1: H, h2: H) =>
    def removeMin(ts: H, as: List[Int]): List[Int] = {
      if (isEmpty(ts)) as
      else findMin(ts) :: removeMin(deleteMin(ts), as)
    }

    val meld1 = meld(h1, h2)
    val min1 = findMin(h1)
    val meld2 = meld(deleteMin(h1), insert(min1, h2))
    val xs1 = removeMin(meld1, Nil)
    val xs2 = removeMin(meld2, Nil)
    xs1 == xs2
  }
}
